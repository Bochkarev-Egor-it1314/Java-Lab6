# Java-Lab6

# Отчет по работе: Реализация задач на Java
Бочкарёв Егор ИТ-13,14

## Общее описание
Данная лабораторная работа демонстрирует применение аннотаций Java и фреймворка тестирования JUnit для создания гибкой и расширяемой системы обработки метаданных. Все задачи реализованы в едином проекте с модульной структурой, включая обработчики аннотаций через Reflection API и комплексное тестирование.

## Структура проекта

src/

└── ru.Bochkarev/

|   ├── Annotations/

|   │   ├── @Cache.java

|   │   ├── @Default.java

|   │   ├── @Invoke.java

|   │   ├── @ToString.java

|   │   ├── @Two.java

|   │   └── @Validate.java

|   ├── Classes/

|   │   ├── CacheClass.java

|   │   ├── DefaultClass.java

|   │   ├── InvalidTwoClass.java

|   │   ├── InvokeClass.java

|   │   ├── ToStringClass.java

|   │   ├── TwoClass.java

|   │   └── ValidateClass.java

|   ├── Main/

|   │   ├── Check.java

|   │   └── Main.java

|   ├── Processors/

|   │   ├── CacheProcessor.java

|   │   ├── DefaultProcessor.java

|   │   ├── InvokeProcessor.java

|   │   ├── ToStringProcessor.java

|   │   ├── TwoProcessor.java

|   │   └── ValidateProcessor.java

|   └── Tests/

|       ├── InvokeTest.java

|       └── TwoTest.java

└── pom.xml

## Детальный анализ методов

### Задание 1.1 (@Invoke)

**<ins>Задача:</ins>**

Разработайте аннотацию @Invoke, со следующими характеристиками:
+ Целью может быть только МЕТОД
+ Доступна во время исполнения программы
+ Не имеет свойств

Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них аннотацией @Invoke.

Реализуйте обработчик (через Reflection API), который находит методы, отмеченные аннотацией @Invoke, и вызывает их автоматически. 

**<ins>Метод решения:</ins>**



**<ins>Код реализации:</ins>**



**<ins>Вывод на экран:</ins>**


***

### Задание 1.2 (@Default)

**<ins>Задача:</ins>**

Разработайте аннотацию @Default, со следующими характеристиками:
+ Целью может быть ТИП или ПОЛЕ
+ Доступна во время исполнения программы
+ Имеет обязательное свойство value типа Class

Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию.

Напишите обработчик, который выводит имя указанного класса по умолчанию. 

**<ins>Метод решения:</ins>**



**<ins>Код реализации:</ins>**



**<ins>Вывод на экран:</ins>**


***

### Задание 1.3 (@ToString)

**<ins>Задача:</ins>**

Разработайте аннотацию @ToString, со следующими характеристиками:
+ Целью может быть ТИП или ПОЛЕ
+ Доступна во время исполнения программы
+ Имеет необязательное свойство valuec двумя вариантами значений: YES или NO
+ Значение свойства по умолчанию: YES

Проаннотируйте класс аннотацией @ToString, а одно из полей – с @ToString(Mode.NO).
  
Создайте метод, который формирует строковое представление объекта, учитывая только те поля, где @ToString имеет значение YES. 

**<ins>Метод решения:</ins>**



**<ins>Код реализации:</ins>**



**<ins>Вывод на экран:</ins>**



***

### Задание 1.4 (@Validate)

**<ins>Задача:</ins>**

Разработайте аннотацию @Validate, со следующими характеристиками:
+ Целью может быть ТИП или АННОТАЦИЯ
+ Доступна во время исполнения программы
+ Имеет обязательное свойство value, типа Class[]

Проаннотируйте класс аннотацией @Validate, передав список типов для проверки.

Реализуйте обработчик, который выводит, какие классы указаны в аннотации. 

**<ins>Метод решения:</ins>**



**<ins>Код реализации:</ins>**



**<ins>Вывод на экран:</ins>**



***

### Задание 1.5 (@Two)

**<ins>Задача:</ins>**

Разработайте аннотацию @Two, со следующими характеристиками:
+ Целью может быть ТИП
+ Доступна во время исполнения программы
+ Имеет два обязательных свойства: first типа String и second типа int

Проаннотируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения.

Реализуйте обработчик, который считывает и выводит значения этих свойств. 

**<ins>Метод решения:</ins>**



**<ins>Код реализации:</ins>**



**<ins>Вывод на экран:</ins>**


***

### Задание 1.6 (@Cache)

**<ins>Задача:</ins>**

Разработайте аннотацию @Cache, со следующими характеристиками:
+ Целью может быть ТИП
+ Доступна во время исполнения программы
+ Имеет необязательное свойство value, типа String[]
+ Значение свойства по умолчанию: пустой массив

Проаннотируйте класс аннотацией @Cache, указав несколько кешируемых областей.

Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что список пуст. 

**<ins>Метод решения:</ins>**



**<ins>Код реализации:</ins>**



**<ins>Вывод на экран:</ins>**



***

### Задание 2.1 (Тестирование)

**<ins>Задача:</ins>**

Создайте тест, используя фреймворк JUnit, который проверяет корректность вызова методов, отмеченных аннотацией @Invoke.
+ Использовать Reflection API для поиска методов с аннотацией.
+ Убедиться, что метод действительно выполняется без исключений.
+ Проверить, что возвращаемое значение или побочный эффект соответствует ожиданиям (например, устанавливает флаг или изменяет состояние объекта).
+ Тест должен использовать аннотацию @BeforeEach для подготовки тестируемого экземпляра класса. 

**<ins>Метод решения:</ins>**



**<ins>Код реализации:</ins>**



**<ins>Вывод на экран:</ins>**



***

### Задание 2.2 (Тестирование)

**<ins>Задача:</ins>**

Разработайте тест, используя фреймворк JUnit, проверяющий корректность обработки аннотации @Two, если её свойства заданы некорректно. Например, строковое свойство first пустое (""), а числовое second отрицательное.
+ Создайте вспомогательный класс с аннотацией @Two(first = "", second = -1).
+ В тесте реализуйте метод, который через Reflection считывает значения аннотации.
+ Если одно из свойств нарушает ожидаемые условия (first – пустая строка, second < 0), то должен быть выброшен IllegalArgumentException.
+ Используйте assertThrows() из JUnit для проверки выбрасываемого исключения. 

**<ins>Метод решения:</ins>**



**<ins>Код реализации:</ins>**



**<ins>Вывод на экран:</ins>**


***

## Вспомогательные методы

+ `public int readInt(Scanner scanner)`

Что делает:

Читает из Scanner целое число, пока пользователь не введёт корректное значение.

Как работает (пошагово):
- Заходит в бесконечный цикл while (true).
- Печатает приглашение "Введите целое число: ".
- Проверяет scanner.hasNextInt() — есть ли следующий токен, который можно распарсить как int.
- Если true: читает int num = scanner.nextInt(); и возвращает num.
- Иначе: печатает сообщение об ошибке и вызывает scanner.next() — чтобы "съесть" неверный токен (иначе hasNextInt() будет снова false и цикл застрянет).

Примеры:

При вводе 42 вернёт 42; при вводе abc — попросит ввести ещё раз.

Код:
```
public int readInt(Scanner scanner) {
        while (true) {
            System.out.print("Введите целое число: ");
            if (scanner.hasNextInt()) {
                int num = scanner.nextInt();
                return num;
            } else {
                System.out.println("Ошибка: введите целое число!");
                scanner.next(); // очищаем неверный ввод
            }
        }
    }
```
